Argirokastritis Polidoros 

στην εργασια ξεκιναω 3 διεργασιες με τον εξης τροπο:
Η 0 διεργασια ξεκιναει με την εντολη: python peer-1.py server 0 127.0.0.1:2196
Η 1 διεργασια ξεκιναει με την εντολη: python peer-1.py client-server 1 2196 2197 ΔΗΛΑΔΗ ΩΣ server που ακουει στην 2197 και συνδεεται με την διεργασια 0 στην πορτα 2196
Η 2 διεργασια ξεκιναει με την εντολη: python peer-1.py client-client 2 2196 2197 Δημαδη συνδεεται με την 0 και την 1 στην πορτα 2196 2197 ΑΝΤΙΣΤΟΙΧΑ.

Δημιουργω ενα αρχειο (synchronization.txt) το οποιο ελεγχει ποτε η διεργασια θα μπει στο factory ετσι ωστε να κανουν reactor  μαζι οι διεργασιες.
Ως vector clocks εχω τρεις μετρητες i0,i1,i2 τους οποιους τους αυξανει καθε διεργασία 0,1,2 αντιστοιχα καθε φορα που στενουν μηνυμα και τα υπολοιπα τα ενημερωνουν μεσω των data που λαμβανουν.
Τα check0,check1,check2 ειναι για να ελεγχουν καθε διεργασια, επειδη αποτελειται η 1 και η 2 απο 2 αντικειμενα, οταν η διεργασια λαβει ενα Question τοτε στελνει 2 Answer σε καθε διεργασια.
Το check0 ειναι για να ελεγχει ο μετρητης i0 να αυξανει 1 φορα γιατι η διεργασια 0 στενει 2 φορες Question στις διεργασιες που ειναι στην ομαδα(δηλαδη 1,2).					
Η global μεταβλητη pid ειναι για την διεργασια 2 για να μπορουν τα 2 αντικειμενα της να συνεργαζονται.
Οι global μεταβλητες data_spl,data_final η 1η ειναι οταν υπαρχει συμφωρηση και τα δεδομενα ανεβαινουν ενωμενα πρεπει να κραταμε σε ενα buffer και να τα βγαζουμε ενα αφου σε καθε μηνυμα εχουμε βαλει ^^ για να μπορουμε να ξερουμε που ειναι το τελος του καθε μηνυματος και ο αντιστοιχος κωδικας ειναι:
 if data_spl != ' ':
			data = data_spl + data
		if '^^' in data:
			data, data1 =data.split('^^', 1)
			data_spl = data1
Η 2η ειναι οταν παιρνουμε τα δεδομενα τα γραφουμε σε ενα buffer για να τα γραψουμε ολα μαζι στο τελος στο αρχειο.
Εχουμε εκτελεση την μεθοδο οταν ερχεται ενα question απανταει ενας απο τους 2 με την μεθοδο:
if int(timeM0)%2 == 0:	
					if int(self.num_of_process) == 2:
						i0 = int(timeM0)
						i1 = int(timeM1)
						i2+=1
						check2=1
						self.sendAnswer(str(i0), str(i1), str(i2), str(self.num_of_process))	
				else:
					if int(self.num_of_process) == 1:
						i0 = int(timeM0)
						i1 += 1
						i2 = int(timeM2)
						check1=1
						
						self.sendAnswer(str(i0), str(i1), str(i2), str(self.num_of_process))
οπου timeM0 ειναι το lamport clock της διεργασιας 0 και οταν το υπολοιπο ειναι 0 στελνει η διεργασια 2 answer.
Αφου στέλνει καθε φορα και αλλη διεργασια answer στελνει και το αντιστοιχο answer στην διεργασια που δεν στελνει για να το βαλει στα δεδομενα της.
Δεν προλαβα να ελεγχω τα max Vector clocks.
